name: Orchestrator - Complete Build

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write

env:
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SERVICE_ROLE: ${{ secrets.SUPABASE_SERVICE_ROLE }}

jobs:
  complete:
    runs-on: ubuntu-latest
    steps:
      - name: Debug ‚Äî show raw comment
        env:
          BODY: ${{ github.event.comment.body }}
        run: |
          echo "=== RAW COMMENT BODY START ==="
          printf "%s\n" "$BODY"
          echo "=== RAW COMMENT BODY END ==="

      - name: Gate ‚Äî run only on /complete-build
        id: gate
        env:
          BODY: ${{ github.event.comment.body }}
        run: |
          set -euo pipefail
          TRIMMED="$(printf "%s" "$BODY" | tr -d '\r' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
          if printf "%s" "$TRIMMED" | grep -qi '^/complete-build$'; then
            echo "match=true" >> "$GITHUB_OUTPUT"
            echo "Found EXACT /complete-build"
          else
            echo "match=false" >> "$GITHUB_OUTPUT"
            echo "No /complete-build; will exit after this step."
          fi

      - name: Stop if not /complete-build
        if: steps.gate.outputs.match != 'true'
        run: echo "Skipping ‚Äî comment was not /complete-build"

      - name: Extract run_id from issue body
        id: extract
        if: steps.gate.outputs.match == 'true'
        env:
          BODY: ${{ github.event.issue.body }}
        run: |
          set -euo pipefail
          RUN_ID=$(printf "%s" "$BODY" | sed -n 's/.*Run ID:[[:space:]]*\([0-9a-f-]\{36\}\).*/\1/p' | head -n1)
          if [ -z "$RUN_ID" ]; then
            echo "No Run ID found in issue body"
            exit 1
          fi
          echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"
          echo "Detected run_id=$RUN_ID"

      - name: Pull run meta (objective + prompt)
        id: runmeta
        if: steps.gate.outputs.match == 'true'
        env:
          RUN_ID: ${{ steps.extract.outputs.run_id }}
        run: |
          set -euo pipefail
          curl -sS "${SUPABASE_URL}/rest/v1/runs?id=eq.${RUN_ID}&select=objective,final_prompt_markdown,created_at" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE}" \
            -H "Accept: application/json" \
            > run.json

          OBJ=$(jq -r '.[0].objective // ""' run.json)
          PROMPT_LEN=$(jq -r '(.[0].final_prompt_markdown // "") | length' run.json)

          echo "objective=$OBJ" >> "$GITHUB_OUTPUT"
          echo "prompt_len=$PROMPT_LEN" >> "$GITHUB_OUTPUT"

      - name: Pull test results for this run
        id: tests
        if: steps.gate.outputs.match == 'true'
        env:
          RUN_ID: ${{ steps.extract.outputs.run_id }}
        run: |
          set -euo pipefail
          curl -sS "${SUPABASE_URL}/rest/v1/orch_tests?run_id=eq.${RUN_ID}&select=test_name,success,log,created_at&order=created_at.asc" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE}" \
            -H "Accept: application/json" \
            > tests.json

          TOTAL=$(jq 'length' tests.json)
          PASSED=$(jq '[ .[] | select(.success == true) ] | length' tests.json)
          FAILED=$(jq '[ .[] | select(.success == false) ] | length' tests.json)

          echo "total=$TOTAL"   >> "$GITHUB_OUTPUT"
          echo "passed=$PASSED" >> "$GITHUB_OUTPUT"
          echo "failed=$FAILED" >> "$GITHUB_OUTPUT"

      - name: Build summary markdown
        id: summary
        if: steps.gate.outputs.match == 'true'
        env:
          RUN_ID: ${{ steps.extract.outputs.run_id }}
          OBJ: ${{ steps.runmeta.outputs.objective }}
          PROMPT_LEN: ${{ steps.runmeta.outputs.prompt_len }}
        run: |
          set -euo pipefail
          {
            echo "### üß™ Test summary for run ${RUN_ID}"
            echo
            echo "**Objective:** ${OBJ}"
            echo
            if [ "${PROMPT_LEN}" -gt 0 ]; then
              echo "- Prompt present: ‚úÖ (len=${PROMPT_LEN})"
            else
              echo "- Prompt present: ‚ùå"
            fi
            echo "- Total tests: $(jq 'length' tests.json) ‚Ä¢ Passed: $(jq '[ .[] | select(.success == true) ] | length' tests.json) ‚Ä¢ Failed: $(jq '[ .[] | select(.success == false) ] | length' tests.json)"
            echo
            if [ "$(jq 'length' tests.json)" -gt 0 ]; then
              echo "| When (UTC) | Test | Success | Notes |"
              echo "|---|---|:---:|---|"
              jq -r '.[] | "| " + (.created_at // "") + " | " + (.test_name // "") + " | " + (if .success then "‚úÖ" else "‚ùå" end) + " | " + ((.log // "" ) | gsub("[\r\n]"; " ") | .[0:240]) + " |"' tests.json
              echo
            else
              echo "_No tests recorded for this run yet._"
              echo
            fi
          } > summary.md
          echo "Built summary.md"

      - name: Build recommendation for Lovable
        id: rec
        if: steps.gate.outputs.match == 'true'
        env:
          RUN_ID: ${{ steps.extract.outputs.run_id }}
          OBJ: ${{ steps.runmeta.outputs.objective }}
        run: |
          set -euo pipefail
          FAILED=$(jq '[ .[] | select(.success == false) ] | length' tests.json)
          if [ "$FAILED" -gt 0 ]; then
            # Build failing list
            jq -r '.[] | select(.success==false) | "- " + (.test_name // "unknown") + ": " + ((.log // "") | gsub("[\r\n]"; " ") | .[0:280])' tests.json > fails.txt

            printf "%s\n" "#### ‚úÖ Orchestrator Recommendation (fix failing checks)
            
**What was done:** Build completed and test suite executed. Some checks failed.

**Suggested next step (Lovable may amend):**
Create a small PR to **fix the failing tests only** ‚Äî do not expand scope.

**Scope:**
- Keep API contract of \`/wallet-ensure-weth\` unchanged.
- Align error taxonomy and log keys if mismatched.
- Add minimal guards where logs indicate missing headers/values/timeouts.

**Failing checks (truncated logs):**
" > recommendation.md

            cat fails.txt >> recommendation.md
            printf "%s\n" "

**Lovable decision rule:** You can follow this recommendation or propose a better minimal fix, but stay within the objective: _${OBJ}_.

\`\`\`
RECOMMENDED_NEXT_STEP_FOR_LOVABLE
Objective: Fix failing checks for run ${RUN_ID}
Context: The above failed tests/logs show exactly what to correct.
Instructions:
- Patch the smallest surface to make all listed checks green.
- Commit and push; then comment /test on this issue.
- If you disagree with the recommendation, reply with your proposed minimal fix and rationale.
\`\`\`
" >> recommendation.md
          else
            printf "%s\n" "#### üéØ Orchestrator Recommendation (next incremental task)

**What was done:** Build completed and **all recorded tests passed**.

**Suggested next step (Lovable may amend):**
**Task 5.2 ‚Äî Permit2 Preflight Integration in BUY Path**

**Goal:** Wire **wallet-ensure-weth** into the BUY preflight so that, when plan-only check returns \`wrap\`, the UI/engine can prompt for \`autoWrap\` or schedule it server-side.

**Scope (keep it minimal):**
- Read-only path (no on-chain) in normal operation.
- Add a guarded call path that sets \`autoWrap=true\` only when policy allows.
- Preserve existing error taxonomy and logging conventions.

**Acceptance (high level):**
- Preflight returns a clear ‚Äúwrap-needed‚Äù signal when WETH < min.
- No on-chain calls unless explicitly allowed by config.
- Existing flows remain unaffected when WETH >= min.

**Lovable decision rule:** You can follow this recommendation or propose a better adjacent next step that keeps momentum toward end-to-end BUY execution on Base.
" > recommendation.md
          fi
          echo "Built recommendation.md"

      - name: Post summary + recommendation
        if: steps.gate.outputs.match == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('summary.md', 'utf8');
            const rec = fs.readFileSync('recommendation.md', 'utf8');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `${summary}\n${rec}`
            })
