name: Orchestrator â€” Complete Build

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write

env:
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SERVICE_ROLE: ${{ secrets.SUPABASE_SERVICE_ROLE }}

jobs:
  complete:
    runs-on: ubuntu-latest
    steps:
      - name: Debug â€” show raw comment
        env:
          BODY: ${{ github.event.comment.body }}
        run: |
          echo "=== RAW COMMENT BODY START ==="
          printf "%s\n" "$BODY"
          echo "=== RAW COMMENT BODY END ==="

      - name: Gate â€” run only on /complete-build
        id: gate
        env:
          BODY: ${{ github.event.comment.body }}
        run: |
          set -euo pipefail
          # Case-insensitive exact match (trim spaces)
          T="$(printf "%s" "$BODY" | tr -d '\r' | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
          if printf "%s" "$T" | grep -qi '^/complete-build$'; then
            echo "match=true" >> "$GITHUB_OUTPUT"
            echo "Found EXACT /complete-build"
            exit 0
          fi
          echo "match=false" >> "$GITHUB_OUTPUT"
          echo "No /complete-build; exiting early."
          # Exit 0 so workflow is visible but does nothing
          exit 0

      - name: Extract run_id from issue body
        id: extract
        if: steps.gate.outputs.match == 'true'
        env:
          BODY: ${{ github.event.issue.body }}
        run: |
          set -euo pipefail
          # Issue body contains a line like:
          # **Run ID:** 7c01abb1-522b-4ae2-8280-a91fe4d2314d
          RUN_ID=$(printf "%s" "$BODY" | sed -n 's/.*Run ID:[[:space:]]*\([0-9a-f-]\{36\}\).*/\1/p' | head -n1)
          if [ -z "$RUN_ID" ]; then
            echo "No Run ID found in issue body"
            exit 1
          fi
          echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"
          echo "Detected run_id=$RUN_ID"

      - name: Pull run meta (objective + prompt)
        id: runmeta
        if: steps.gate.outputs.match == 'true'
        env:
          RUN_ID: ${{ steps.extract.outputs.run_id }}
        run: |
          set -euo pipefail
          curl -sS "${SUPABASE_URL}/rest/v1/runs?id=eq.${RUN_ID}&select=objective,final_prompt_markdown,created_at" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE}" \
            -H "Accept: application/json" \
            > run.json

          echo "Downloaded runs meta:"
          cat run.json

          OBJ=$(jq -r '.[0].objective // ""' run.json)
          PROMPT_LEN=$(jq -r '(.[0].final_prompt_markdown // "") | length' run.json)

          echo "objective=$OBJ" >> "$GITHUB_OUTPUT"
          echo "prompt_len=$PROMPT_LEN" >> "$GITHUB_OUTPUT"

      - name: Pull test results for this run
        id: tests
        if: steps.gate.outputs.match == 'true'
        env:
          RUN_ID: ${{ steps.extract.outputs.run_id }}
        run: |
          set -euo pipefail
          curl -sS "${SUPABASE_URL}/rest/v1/orch_tests?run_id=eq.${RUN_ID}&select=test_name,success,log,created_at&order=created_at.asc" \
            -H "apikey: ${SUPABASE_SERVICE_ROLE}" \
            -H "Authorization: Bearer ${SUPABASE_SERVICE_ROLE}" \
            -H "Accept: application/json" \
            > tests.json

          echo "Downloaded tests:"
          cat tests.json

          TOTAL=$(jq 'length' tests.json)
          PASSED=$(jq '[ .[] | select(.success == true) ] | length' tests.json)
          FAILED=$(jq '[ .[] | select(.success == false) ] | length' tests.json)

          echo "total=$TOTAL"   >> "$GITHUB_OUTPUT"
          echo "passed=$PASSED" >> "$GITHUB_OUTPUT"
          echo "failed=$FAILED" >> "$GITHUB_OUTPUT"

      - name: Build summary markdown
        id: summary
        if: steps.gate.outputs.match == 'true'
        env:
          RUN_ID: ${{ steps.extract.outputs.run_id }}
          OBJ: ${{ steps.runmeta.outputs.objective }}
          PROMPT_LEN: ${{ steps.runmeta.outputs.prompt_len }}
        run: |
          set -euo pipefail
          {
            echo "### ðŸ§ª Test summary for run ${RUN_ID}"
            echo
            echo "**Objective:** ${OBJ}"
            echo
            if [ "${PROMPT_LEN}" -gt 0 ]; then
              echo "- Prompt present: âœ… (len=${PROMPT_LEN})"
            else
              echo "- Prompt present: âŒ"
            fi
            echo "- Total tests: $(jq 'length' tests.json) â€¢ Passed: $(jq '[ .[] | select(.success == true) ] | length' tests.json) â€¢ Failed: $(jq '[ .[] | select(.success == false) ] | length' tests.json)"
            echo
            if [ "$(jq 'length' tests.json)" -gt 0 ]; then
              echo "| When (UTC) | Test | Success | Notes |"
              echo "|---|---|:---:|---|"
              jq -r '.[] | "| " + (.created_at // "") + " | " + (.test_name // "") + " | " + (if .success then "âœ…" else "âŒ" end) + " | " + ((.log // "" ) | gsub("[\r\n]"; " ") | .[0:240]) + " |"' tests.json
              echo
            else
              echo "_No tests recorded for this run yet._"
              echo
            fi
          } > summary.md
          echo "Built summary.md"

      - name: Build recommendation for Lovable
        id: rec
        if: steps.gate.outputs.match == 'true'
        env:
          RUN_ID: ${{ steps.extract.outputs.run_id }}
          OBJ: ${{ steps.runmeta.outputs.objective }}
        run: |
          set -euo pipefail
          FAILED=$(jq '[ .[] | select(.success == false) ] | length' tests.json)
          if [ "$FAILED" -gt 0 ]; then
            jq -r '.[] | select(.success==false) | "- " + (.test_name // "unknown") + ": " + ((.log // "") | gsub("[\r\n]"; " ") | .[0:280])' tests.json > fails.txt

            cat > recommendation.md <<'REC'
#### âœ… Orchestrator Recommendation (fix failing checks)

**What was done:** Build completed and test suite executed. Some checks failed.

**Suggested next step (Lovable may amend):**  
Create a small PR to **fix the failing tests only** â€” do not expand scope.

**Scope:**
- Keep API contract of `/wallet-ensure-weth` unchanged.
- Align error taxonomy and log keys if mismatched.
- Add minimal guards where logs indicate missing headers/values/timeouts.

**Failing checks (truncated logs):**
REC
            cat fails.txt >> recommendation.md
            cat >> recommendation.md <<REC

**Lovable decision rule:** You can follow this recommendation or propose a better minimal fix, but stay within the objective: _${OBJ}_.

\`\`\`
RECOMMENDED_NEXT_STEP_FOR_LOVABLE
Objective: Fix failing checks for run ${RUN_ID}
Context: The above failed tests/logs show exactly what to correct.
Instructions:
- Patch the smallest surface to make all listed checks green.
- Commit and push; then comment /test on this issue.
- If you disagree with the recommendation, reply with your proposed minimal fix and rationale.
\`\`\`
REC
          else
            cat > recommendation.md <<REC
#### ðŸŽ¯ Orchestrator Recommendation (next incremental task)

**What was done:** Build completed and **all recorded tests passed**.

**Suggested next step (Lovable may amend):**  
**Task 5.2 â€” Permit2 Preflight Integration in BUY Path**

**Goal:** Wire **wallet-ensure-weth** into the BUY preflight so that, when plan-only check returns \`wrap\`, the UI/engine can prompt for \`autoWrap\` or schedule it server-side.

**Scope (keep it minimal):**
- Read-only path (no on-chain) in normal operation.
- Add a guarded call path that sets \`autoWrap=true\` only when policy allows.
- Preserve existing error taxonomy and logging conventions.

**Acceptance (high level):**
- Preflight returns a clear â€œwrap-neededâ€ signal when WETH < min.
- No on-chain calls unless explicitly allowed by config.
- Existing flows remain unaffected when WETH >= min.

**Lovable decision rule:** You can follow this recommendation or propose a better adjacent next step that keeps momentum toward end-to-end BUY execution on Base.
REC
          fi
          echo "Built recommendation.md"

      - name: Post summary + recommendation
        if: steps.gate.outputs.match == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('summary.md', 'utf8');
            const rec = fs.readFileSync('recommendation.md', 'utf8');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `${summary}\n${rec}`
            })
