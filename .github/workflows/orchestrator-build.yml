name: Orchestrator Build Trigger (step2)

on:
  issue_comment:
    types: [created, edited]

permissions:
  contents: read
  issues: write

jobs:
  start_build:
    runs-on: ubuntu-latest
    steps:
      - name: Debug comment body
        env:
          BODY: ${{ github.event.comment.body }}
        run: |
          echo "=== RAW COMMENT BODY START ==="
          printf "%s\n" "$BODY"
          echo "=== RAW COMMENT BODY END ==="

      - name: Check for /start-build
        id: check
        env:
          BODY: ${{ github.event.comment.body }}
        run: |
          if echo "$BODY" | grep -qi '^/start-build$'; then
            echo "match=true" >> "$GITHUB_OUTPUT"
            echo "Found EXACT /start-build"
          else
            echo "match=false" >> "$GITHUB_OUTPUT"
            echo "Did NOT find exact /start-build"
          fi

      - name: Extract run_id from issue body
        if: steps.check.outputs.match == 'true'
        id: grab
        env:
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          echo "== ISSUE BODY START =="
          printf "%s\n" "$ISSUE_BODY"
          echo "== ISSUE BODY END =="

          # Normalize: remove CR, strip markdown asterisks, collapse spaces
          CLEAN=$(printf "%s" "$ISSUE_BODY" | tr -d '\r' | sed 's/\*\*//g' | tr -s ' ')

          # Try 1: explicit 'Run ID:' line
          RUN_ID=$(printf "%s" "$CLEAN" | sed -nE 's/.*Run ID:\s*([0-9a-f-]{36}).*/\1/p' | head -n1)

          # Try 2: first UUID anywhere in the body (fallback)
          if [ -z "$RUN_ID" ]; then
            RUN_ID=$(printf "%s" "$CLEAN" | grep -oE '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' | head -n1)
          fi

          if [ -z "$RUN_ID" ]; then
            echo "Could not find Run ID in issue body (after normalization)"; exit 1
          fi

          echo "Extracted run_id: $RUN_ID"
          echo "run_id=$RUN_ID" >> "$GITHUB_OUTPUT"

      - name: Download plan artifact (best-effort)
        if: steps.check.outputs.match == 'true'
        uses: actions/download-artifact@v4
        with:
          name: orchestrator-plan-${{ steps.grab.outputs.run_id }}
          path: .
        continue-on-error: true

      - name: Build Lovable brief (rich if artifact exists)
        if: steps.check.outputs.match == 'true'
        id: brief
        run: |
          if [ -f orchestrator.json ]; then
            OBJECTIVE=$(jq -r '.objective' orchestrator.json)
            echo "Found orchestrator.json with objective: $OBJECTIVE"
            TASKS=$(jq -r '.tasks[] | "* **\(.title)**\n  " + ( .steps | map("- " + .) | join("\n  ")) + "\n"' orchestrator.json)
            ACCEPT=$(jq -r '.acceptance // [] | map("- " + .) | join("\n")' orchestrator.json)
          else
            OBJECTIVE="(Objective not found in artifact)"
            TASKS="(Tasks artifact missing; see issue text)"
            ACCEPT="(Acceptance unknown)"
          fi

          {
            echo "### Lovable Build Brief"
            echo
            echo "**Context / Objective**"
            echo "$OBJECTIVE"
            echo
            echo "**What to build**"
            echo "$TASKS"
            echo
            echo "**Acceptance checks**"
            echo "$ACCEPT"
            echo
            echo "**Notes**"
            echo "- Follow repository code style & TypeScript strictness"
            echo "- Log every step and surface errors"
            echo "- Keep changes small and incremental; commit early"
          } > lovable_brief.md





      - name: Post Lovable build brief on the issue
        if: steps.check.outputs.match == 'true'
        uses: actions/github-script@v7
        env:
          RUN_ID: ${{ steps.grab.outputs.run_id }}
        with:
          script: |
            const runId = process.env.RUN_ID;
            const body = [
              `âœ… **Build started (manual via Lovable)**`,
              `**Run ID:** ${runId}`,
              ``,
              `**What to do in Lovable:**`,
              `1. Pull the latest repo.`,
              `2. Implement the tasks attached to this run in small, testable PRs.`,
              `3. Keep logs/notes; surface any blockers.`,
              ``,
              `_Posted automatically by the Orchestrator_`
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });

      - name: Mark run as in_build (Supabase)
        if: steps.check.outputs.match == 'true'
        env:
          ORCH_MARK_URL: ${{ secrets.ORCH_MARK_URL }}
          ORCH_ADMIN_SECRET: ${{ secrets.ORCH_ADMIN_SECRET }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          RUN_ID: ${{ steps.grab.outputs.run_id }}
        run: |
          set -e
          PAYLOAD=$(jq -n --arg run_id "$RUN_ID" --arg status "in_build" '{run_id:$run_id,status:$status}')
          echo "POSTing to $ORCH_MARK_URL"

          # The Function Gateway expects a valid Supabase JWT in Authorization.
          # Use the ANON key there, and keep our custom admin header for your function's own check.
          HTTP_CODE=$(curl -sS -o resp.txt -w "%{http_code}" -X POST "$ORCH_MARK_URL" \
            -H "content-type: application/json" \
            -H "Authorization: Bearer $SUPABASE_ANON_KEY" \
            -H "x-orch-admin: $ORCH_ADMIN_SECRET" \
            -d "$PAYLOAD")

          echo "HTTP $HTTP_CODE"
          echo "Response:"
          cat resp.txt || true

          if [ "$HTTP_CODE" -ge 300 ]; then
            echo "Mark endpoint failed (HTTP $HTTP_CODE)"; exit 1
          fi
